{"name":"expo-updates","kind":0,"kindString":"Project","originalName":"","children":[{"name":"UpdateEventType","kind":4,"kindString":"Enumeration","children":[{"name":"ERROR","kind":16,"kindString":"Enumeration member","comment":{"shortText":"An error occurred trying to fetch the latest update."},"defaultValue":"\"error\""},{"name":"NO_UPDATE_AVAILABLE","kind":16,"kindString":"Enumeration member","comment":{"shortText":"No updates are available, and the most up-to-date bundle of this experience is already running."},"defaultValue":"\"noUpdateAvailable\""},{"name":"UPDATE_AVAILABLE","kind":16,"kindString":"Enumeration member","comment":{"shortText":"A new update has finished downloading to local storage. If you would like to start using this\nupdate at any point before the user closes and restarts the app on their own, you can call\n[`Updates.reloadAsync()`](#reloadasync) to launch this new update."},"defaultValue":"\"updateAvailable\""}]},{"name":"UpdateCheckResult","kind":4194304,"kindString":"Type alias","type":{"type":"reflection","declaration":{"name":"__type","kind":65536,"kindString":"Type literal","children":[{"name":"isAvailable","kind":1024,"kindString":"Property","comment":{"shortText":"`true` if an update is available, `false` if you're already running the most up-to-date JS bundle."},"type":{"type":"intrinsic","name":"boolean"}},{"name":"manifest","kind":1024,"kindString":"Property","flags":{"isOptional":true},"comment":{"shortText":"If `isAvailable` is `true`, the manifest of the available update. Undefined otherwise."},"type":{"type":"reference","name":"Manifest"}}]}}},{"name":"UpdateEvent","kind":4194304,"kindString":"Type alias","comment":{"shortText":"An object that is passed into each event listener when an auto-update check has occurred."},"type":{"type":"reflection","declaration":{"name":"__type","kind":65536,"kindString":"Type literal","children":[{"name":"manifest","kind":1024,"kindString":"Property","flags":{"isOptional":true},"comment":{"shortText":"If `type === Updates.UpdateEventType.UPDATE_AVAILABLE`, the manifest of the newly downloaded\nupdate. Undefined otherwise."},"type":{"type":"reference","name":"Manifest"}},{"name":"message","kind":1024,"kindString":"Property","flags":{"isOptional":true},"comment":{"shortText":"If `type === Updates.UpdateEventType.ERROR`, the error message. Undefined otherwise."},"type":{"type":"intrinsic","name":"string"}},{"name":"type","kind":1024,"kindString":"Property","comment":{"shortText":"Type of the event."},"type":{"type":"reference","name":"UpdateEventType"}}]}}},{"name":"UpdateFetchResult","kind":4194304,"kindString":"Type alias","type":{"type":"reflection","declaration":{"name":"__type","kind":65536,"kindString":"Type literal","children":[{"name":"isNew","kind":1024,"kindString":"Property","comment":{"shortText":"`true` if the fetched bundle is new (i.e. a different version than what's currently running),\n`false` otherwise."},"type":{"type":"intrinsic","name":"boolean"}},{"name":"manifest","kind":1024,"kindString":"Property","flags":{"isOptional":true},"comment":{"shortText":"If `isNew` is `true`, the manifest of the newly downloaded update. Undefined otherwise."},"type":{"type":"reference","name":"Manifest"}}]}}},{"name":"isEmergencyLaunch","kind":32,"kindString":"Variable","flags":{"isConst":true},"comment":{"shortText":"`expo-updates` does its very best to always launch monotonically newer versions of your app so\nyou don't need to worry about backwards compatibility when you put out an update. In very rare\ncases, it's possible that `expo-updates` may need to fall back to the update that's embedded in\nthe app binary, even after newer updates have been downloaded and run (an \"emergency launch\").\nThis boolean will be `true` if the app is launching under this fallback mechanism and `false`\notherwise. If you are concerned about backwards compatibility of future updates to your app, you\ncan use this constant to provide special behavior for this rare case."},"type":{"type":"intrinsic","name":"boolean"},"defaultValue":"..."},{"name":"manifest","kind":32,"kindString":"Variable","flags":{"isConst":true},"comment":{"shortText":"If `expo-updates` is enabled, this is the [manifest](/guides/how-expo-works#expo-development-server)\nobject for the update that's currently running.","text":"In development mode, or any other environment in which `expo-updates` is disabled, this object is empty.\n"},"type":{"type":"union","types":[{"type":"reference","name":"Manifest"},{"type":"intrinsic","name":"object"}]},"defaultValue":"..."},{"name":"releaseChannel","kind":32,"kindString":"Variable","flags":{"isConst":true},"comment":{"shortText":"The name of the release channel currently configured in this standalone or bare app."},"type":{"type":"intrinsic","name":"string"},"defaultValue":"..."},{"name":"updateId","kind":32,"kindString":"Variable","flags":{"isConst":true},"comment":{"shortText":"If `expo-updates` is enabled, the UUID that uniquely identifies the currently running update.\nThe UUID is represented in its canonical string form (`xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`)\nand will always use lowercase letters. In development mode, or any other environment in which\n`expo-updates` is disabled, this value is `null`."},"type":{"type":"union","types":[{"type":"intrinsic","name":"string"},{"type":"literal","value":null}]},"defaultValue":"..."},{"name":"addListener","kind":64,"kindString":"Function","signatures":[{"name":"addListener","kind":4096,"kindString":"Call signature","comment":{"shortText":"Adds a callback to be invoked when updates-related events occur (such as upon the initial app load)\ndue to auto-update settings chosen at build-time.","returns":"Returns an `EventSubscription` object on which you can call `remove()` if\nyou would like to unsubscribe from the listener.\n"},"parameters":[{"name":"listener","kind":32768,"kindString":"Parameter","comment":{"text":"A function that will be invoked with an instance of [`UpdateEvent`](#updateevent)\nand should not return any value."},"type":{"type":"reflection","declaration":{"name":"__type","kind":65536,"kindString":"Type literal","signatures":[{"name":"__type","kind":4096,"kindString":"Call signature","parameters":[{"name":"event","kind":32768,"kindString":"Parameter","type":{"type":"reference","name":"UpdateEvent"}}],"type":{"type":"intrinsic","name":"void"}}]}}}],"type":{"type":"reference","name":"EventSubscription"}}]},{"name":"checkForUpdateAsync","kind":64,"kindString":"Function","signatures":[{"name":"checkForUpdateAsync","kind":4096,"kindString":"Call signature","comment":{"shortText":"Checks the server to see if a newly deployed update to your project is available. Does not\nactually download the update. This method cannot be used in development mode, and the returned\n`Promise` will be rejected if you try to do so.","returns":"A Promise that fulfils with [`UpdateCheckResult`](#updatecheckresult) object.\n\nThe `Promise` rejects if the app is in development mode, or if there is an unexpected error or\ntimeout communicating with the server.\n"},"type":{"type":"reference","typeArguments":[{"type":"reference","name":"UpdateCheckResult"}],"name":"Promise"}}]},{"name":"fetchUpdateAsync","kind":64,"kindString":"Function","signatures":[{"name":"fetchUpdateAsync","kind":4096,"kindString":"Call signature","comment":{"shortText":"Downloads the most recently deployed update to your project from server to the device's local storage.\nThis method cannot be used in development mode, and the returned `Promise` will be rejected if\nyou try to do so.","returns":"A Promise that fulfils with [`UpdateFetchResult`](#updatefetchresult) object.\n\nThe Promise rejects if the app is in development mode, or if there is an unexpected error or\ntimeout communicating with the server.\n"},"type":{"type":"reference","typeArguments":[{"type":"reference","name":"UpdateFetchResult"}],"name":"Promise"}}]},{"name":"reloadAsync","kind":64,"kindString":"Function","signatures":[{"name":"reloadAsync","kind":4096,"kindString":"Call signature","comment":{"shortText":"Instructs the app to reload using the most recently downloaded version. This is useful for\ntriggering a newly downloaded update to launch without the user needing to manually restart the app.","text":"It is not recommended to place any meaningful logic after a call to `await Updates.reloadAsync()`.\nThis is because the `Promise` is resolved after verifying that the app can be reloaded, and\nimmediately before posting an asynchronous task to the main thread to actually reload the app.\nIt is unsafe to make any assumptions about whether any more JS code will be executed after the\n`Updates.reloadAsync` method call resolves, since that depends on the OS and the state of the\nnative module and main threads.\n\nThis method cannot be used in development mode, and the returned `Promise` will be rejected if you try to do so.\n","returns":"Returns a `Promise` that fulfils right before the reload instruction is sent to the JS runtime,\nor rejects if it cannot find a reference to the JS runtime.\nIf the `Promise` is rejected in production mode, it most likely means you have installed the\nmodule incorrectly. Double check you've followed the instructions above. In particular, on iOS\nensure that you set the `bridge` property on `EXUpdatesAppController` with a pointer to the\n`RCTBridge` you want to reload, and on Android ensure you either call `UpdatesController.initialize`\nwith the instance of `ReactApplication` you want to reload, or call `UpdatesController.setReactNativeHost`\nwith the proper instance of `ReactNativeHost`.\n"},"type":{"type":"reference","typeArguments":[{"type":"intrinsic","name":"void"}],"name":"Promise"}}]}]}